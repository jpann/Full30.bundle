import httplib
import json

def MetadataObjectForURL(url):
    video_hash = url.rsplit('/', 1)[-1]

    content = HTTP.Request("https://www.full30.com/video/" + video_hash, cacheTime = CACHE_1MONTH).content
    page = HTML.ElementFromString(content)

    #Log.Info('HTML-> ' + content)

    title = page.xpath("//head//meta[@property='og:title']")[0].get('content')
    description = page.xpath("//head//meta[@property='og:description']")[0].get('content')
    thumb = page.xpath("//head//meta[@property='og:image']")[1].get('content')

    return VideoClipObject(
        title = title,
        summary = description,
        thumb = Callback(Thumb, url=thumb)
        )     

def MediaObjectsForURL(url):
    Log.Info('MetadataObjectForURL - url = ' + url)

    return [
        MediaObject(
            video_codec = VideoCodec.H264,
            audio_codec = AudioCodec.AAC,
            container = Container.MP4,
            audio_channels = 2,
            optimized_for_streaming = True,
            parts = [PartObject(key=Callback(PlayVideo, url = url))]
        )
    ]

REGEX_VIDEO_URL = Regex('src="(?P<video_url>https://videos.full30.com[^"]+)"')
@indirect
def PlayVideo(url):
    Log.Info('PlayVideo: ' + url)

    resolutions = get_video_resolutions(url)

    video_url = resolutions[0]["mp4_url"]

    Log.Info('VideoUrl: ' + video_url)

    if not video_url:
        raise Ex.MediaNotAvailable

    return IndirectResponse(VideoClipObject, key=video_url)

def Thumb(url):
  try:
    data = HTTP.Request(url, cacheTime = CACHE_1MONTH).content
    return DataObject(data, 'image/jpeg')
  except:
    return Redirect(R(ICON))

def get_video_resolutions(url):
    resolutions = []

    data = HTTP.Request(url, cacheTime = CACHE_1HOUR).content

    lines = data.splitlines()

    for line in lines:
        line_json = json.loads(line)

        if line_json["type"] == "object" and line_json["name"].endswith(".mp4"):
            resolutions.append({ "resolution" : line_json["name"], "etag" : line_json["etag"], "mp4_url" : url + "/" + line_json["name"] })

    return resolutions

